#!/usr/bin/env node

const ID = 0,TYPE = 1,VALUE = 2,EXTRA = 3,EXTRA2 = 4

const fs = require('fs')
const path = require('path')
const args = require('pico-args')
const CleanCSS = require('clean-css')

const defaults = {
	bundles:['proj:main,bundle1,bundle2','bundle name, comma separated if more than one'],
	wd:['.','working directory'],
	main:['main','path to main directory'],
	cfg:['cfg','path to configuration directory'],
	bin:['bin','path to binary/output directory'],
	lean:[true,'embed lean library'],
	pico:[true,'embed pico library'],
	help:[false,'show this help']
}
const opt = args.parse(defaults)
if (opt.help || !opt.bundles) return args.usage(defaults)
args.print('build options',opt)

const bundles =  opt.bundles.split(',')
const cwd = path.resolve(process.cwd(),opt.wd)
const mainDir = path.resolve(cwd,opt.main)
const cfgDir = path.resolve(cwd,opt.cfg)
const distDir = path.resolve(cwd,opt.bin)

function mkdirPSync(targetDir, access, cb) {
	const sep = path.sep

	targetDir.split(sep).reduce((parentDir, childDir) => {
		const curDir = path.resolve(parentDir, childDir)
		fs.mkdirSync(curDir, access)

		return curDir
	}, sep)
}

function setup(cb){
	let pair = bundles[0].split(':')
	const proj = pair[0]

	try { mkdirPSync(path.resolve(distDir, proj, opt.main), 0o755) }
	catch (exp) { if ('EEXIST' !== exp.code) return cb(err) }

	bundles.forEach((bundle, index) => {
		pair = bundle.split(':')
		const config = pair[0]
		const entry = pair[1] || pair[0]
		const configFName = config + '.json'
		const rawProjPath = path.resolve(cfgDir, configFName)
		const configPath = path.resolve(cfgDir, 'build', configFName)

		fs.stat(rawProjPath, (err, stat) => {
			if (err) return cb(err)
			try{ var json = JSON.parse(fs.readFileSync(rawProjPath)) }
			catch(exp){ return cb(exp) }
			cb(null,
				json,
				0 === index,
				entry,
				rawProjPath,
				configPath,
				path.resolve(distDir, proj, opt.main, entry + '.js'))
		})
	})
}

function getPath(spec, include){
	switch(spec[TYPE]){
	case 'file':
		include.add(spec[VALUE])
		return false
	case 'view':
	case 'ctrl':
		const path = spec[EXTRA] || spec[ID]
		if (Array.isArray(path)) path.forEach(p => include.add(p))
		else include.add(path)
		return true
	case 'map':
	case 'list':
		return true
	}
	return false
}

function scanObj(obj, include, cb){
    if (!obj) return cb(null, include)
	
	const keys = Object.keys(obj)
    if (!keys.length) return cb(null, include)

	scan(keys.map(k => obj[k] ), include, cb)
}

function scan(arr, include, cb){
    if (!arr || !Array.isArray(arr) || !arr.length) return cb(null, include)

    const spec = arr.shift()

    if (getPath(spec, include)){
		if ('map' === spec[TYPE]){
			return scanObj(spec[VALUE], include, (err, include) => {
				if (err) return cb(err)
				scan(arr, include, cb)
			})
		}

        return scan(spec[VALUE], include, (err, include) => {
            if (err) return cb(err)
            scan(arr, include, cb)
        })
    }
    scan(arr, include, cb)
}

process.chdir(cwd)

setup((err, project, isMain, bundlejs, rawProjPath, projPath, outPath) => {
	if (err) return console.error(err)

	const deps = []
	if (isMain) {
		opt.lean && deps.push(path.resolve(cwd,'lib','lean','lean.min.js'))
		opt.pico && deps.push(path.resolve(cwd,'lib','common','pico.min.js'))
	}


	const handler = {get(target,name){
		switch(name){
		case 'load':
		case 'ajax': return null
		default: return () => {}
		}
	}}

	// global
	pico = require('pico-common/bin/pico-cli.js')
	__ = window = document = new Proxy({}, handler)

	const replace = {
		['cfg/' + path.basename(rawProjPath)]: JSON.stringify(project)
	}
	scan(project, new Set, (err, include) => {
		if (err) return console.error(err)

		pico.export('pico/build')({
			entry: path.resolve(mainDir, bundlejs + '.js'),
			output: outPath,
			deps,
			include: Array.from(include),
			exclude: [
				'main/' + path.basename(bundlejs)
			],
			replace
		})
	})
})
