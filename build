#!/usr/bin/env node

const ID=0,TYPE=1,VALUE=2,EXTRA=3,EXTRA2=4

const fs=require('fs')
const path=require('path')
const args=require('pico-args')
const CleanCSS=require('clean-css')
const defaults={
	proj:['','project name'],
	wd:['.','working directory'],
	mod:['mod','path to module directory'],
	cfg:['cfg','path to configuration directory'],
	bin:['bin','path to binary/output directory'],
	entry:['main.js','entry point filename'],
	lean:[true,'embed lean library'],
	pico:[true,'embed pico library'],
	help:[false,'show this help']
}
const opt=args.parse(defaults)
const proj=opt.proj
const cwd=path.resolve(process.cwd(),opt.wd)
const modDir=path.resolve(cwd,opt.mod)
const cfgDir=path.resolve(cwd,opt.cfg)
const distDir=path.resolve(cwd,opt.bin)
const mainjs=opt.entry

if (opt.help || !opt.proj) return args.usage(defaults)
args.print('build options',opt)

function setup(cb){
    const rawProjName=['proj']

    proj && rawProjName.push(proj)

    const
    rawProjPath=path.resolve(cfgDir,`${rawProjName.join('-')}.json`),
    projPath=path.resolve(cfgDir,'proj.json')

    fs.stat(rawProjPath, (err, stat)=>{
        if (err) return cb(err)
		try{var json=JSON.parse(fs.readFileSync(rawProjPath))}
		catch(exp){return console.error(exp)}
		fs.mkdir(distDir, 0o755, (err)=>{
			if (err && 'EEXIST'!==err.code) return cb(err)
			fs.mkdir(path.resolve(distDir,proj), 0o755, (err)=>{
				if (err && 'EEXIST'!==err.code) return cb(err)
				cb(null, json, projPath, path.resolve(distDir,proj,'proj.js'))
			})
		})
    })
}

function getPath(spec, include){
	switch(spec[TYPE]){
	case 'file':
		include.add(spec[VALUE])
		return false
	case 'view':
	case 'ctrl':
		const path=spec[EXTRA]||spec[ID]
		if (Array.isArray(path)) path.forEach((p)=>{include.add(p)})
		else include.add(path)
		return true
	case 'map':
	case 'list':
		return true
	}
	return false
}

function scanObj(obj, include, cb){
    if (!obj) return cb(null, include)
	
	const keys = Object.keys(obj)
    if (!keys.length) return cb(null, include)

	scan( keys.map( k => obj[k] ), include, cb)
}

function scan(arr, include, cb){
    if (!arr || !Array.isArray(arr) || !arr.length) return cb(null, include)

    const spec=arr.shift()

    if (getPath(spec, include)){
		if ('map' === spec[TYPE]){
			return scanObj(spec[VALUE], include, (err, include)=>{
				if (err) return cb(err)
				scan(arr, include, cb)
			})
		}

        return scan(spec[VALUE], include, (err, include)=>{
            if (err) return cb(err)
            scan(arr, include, cb)
        })
    }
    scan(arr, include, cb)
}

process.chdir(cwd)

setup((err, project, projPath, outPath)=>{
	if (err) return console.error(err)

	const deps = []
	opt.lean && deps.push(path.resolve(cwd,'lib','lean','lean.min.js'))
	opt.pico && deps.push(path.resolve(cwd,'lib','common','pico.min.js'))


	const handler={get(target,name){
		switch(name){
		case 'load':
		case 'ajax': return null
		default: return ()=>{}
		}
	}}

	// global
	console.log(process.cwd())
	pico=require('pico-common/bin/pico-cli.js')
	__=window=document=new Proxy({},handler)

	fs.writeFile(projPath, JSON.stringify(project),(err)=>{
		if (err) return console.error(err)

		scan(project, new Set, (err, include)=>{
			if (err) return console.error(err)

			pico.export('pico/build')({
				entry:path.resolve(modDir,mainjs),
				output:outPath,
				deps,
				include,
				exclude:[path.basename(mainjs,'.js')] 
			})
		})
	})
})
