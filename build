#!/usr/bin/env node

const
DEPS=0,STYLE=1,MIDDLEWARES=2,SPEC=3,PANE=4,FLYER=5,
ID=0,TYPE=1,VALUE=2,EXTRA=3,

fs=require('fs'),
path=require('path'),
args=require('pico-args'),
CleanCSS=require('clean-css'),
defaults={
	proj:['','project name'],
	env:['pro','environment: dev, st or pro'],
	wd:['.','working directory'],
	url:['','server url'],
	mod:['mod','path to module directory'],
	cfg:['cfg','path to configuration directory'],
	bin:['bin','path to binary/output directory'],
	entry:['main.js','entry point filename'],
	underscore:[true,'embed underscore library'],
	backbone:[true,'embed backbone library'],
	lean:[true,'embed lean library'],
	pico:[true,'embed pico library']
},
opt=args.parse(defaults),
proj=opt.proj,
env=opt.env,
cwd=path.resolve(process.cwd(),opt.wd),
modDir=path.resolve(cwd,opt.mod),
cfgDir=path.resolve(cwd,opt.cfg),
distDir=path.resolve(cwd,opt.bin),
mainjs=opt.entry,
setup=function(cb){
    const
    rawProjPath=path.resolve(cfgDir,`proj-${proj}.json`),
    rawEnvPath=path.resolve(cfgDir,`env-${proj}-${env}.json`),
    projPath=path.resolve(cfgDir,'project.json'),
    envPath=path.resolve(cfgDir,'env.json')

    fs.stat(rawProjPath, (err, stat)=>{
        if (err) return cb(err)
        fs.stat(rawEnvPath, (err, stat)=>{
            if (err) return cb(err)
			try{var json=JSON.parse(fs.readFileSync(rawProjPath))}
			catch(exp){return console.error(exp)}
            fs.writeFileSync(envPath, fs.readFileSync(rawEnvPath))
            fs.mkdir(distDir, 0o755, (err)=>{
                if (err && 'EEXIST'!==err.code) return cb(err)
                fs.mkdir(path.resolve(distDir,proj), 0o755, (err)=>{
                    if (err && 'EEXIST'!==err.code) return cb(err)
                    cb(null, json, projPath, path.resolve(distDir,proj,'project.js'))
                })
            })
        })
    })
},
getPath=function(spec, narr, include, style){
	switch(spec[TYPE]){
	case 'file':
		if ('css'===spec[ID]){
			style.add(spec[VALUE])
		}else{
			include.add(spec[VALUE])
			narr.push(spec)
		}
		return false
	case 'view':
	case 'ctrl':
		const path=spec[EXTRA]||spec[ID]
		if (Array.isArray(path)) path.forEach((p)=>{include.add(p)})
		else include.add(path)

		const nspec=spec.slice()
		nspec[VALUE]=[]
		narr.push(nspec)
		break
	default:
		narr.push(spec)
		return false
	}
    return true
},
scan=function(arr, narr, include, style, cb){
    if (!arr || !Array.isArray(arr) || !arr.length) return cb(null, include, style)
    const spec=arr.shift()
    if (getPath(spec, narr, include, style)){
        scan(spec[VALUE], narr[narr.length-1][VALUE], include, style, (err, include, style)=>{
            if (err) return console.error(err)
            scan(arr, narr, include, style, cb)
        })
    }else{
        scan(arr, narr, include, style, cb)
    }
},
scanPane=function(keys, panes, npanes, include, style, cb){
    if (!keys || !keys.length) return cb(null, include, style)
    const 
	key=keys.shift(),
	pane=panes[key]
    if (!pane) return scanPane(keys, panes, npanes, include, style, cb)
	const npane=[]
	npanes[key]=npane
    scan(pane, npane, include, style, (err, include, style)=>{
        if (err) return console.error(err)
        scanPane(keys, panes, npanes, include, style, cb)
    })
},
writeCSS=function(style, cb){
	const	
	src=proj+'.css',
	target=path.resolve(distDir,proj,proj+'.css'),
	relative=path.relative(cwd,modDir)

	let content=''

	style.forEach((v)=>{
		content+=`@import url(${relative+path.sep+v});\n`
	})
	fs.writeFile(src, content, 'utf8', (err)=>{
		if (err) cb(err)
		new CleanCSS({rebase:true,sourceMap:true,target:target}).minify(content, (err, minified)=>{
			if (err) return cb(err)
			fs.writeFile(target, minified.styles, 'utf8', (err)=>{
				if (err) return cb(err)
				fs.writeFile(target+'.map', minified.sourceMap.toString(), 'utf8', cb)
			})
		})
	})
}

if (!opt.proj) return args.usage(defaults)
args.print('build options',opt)

process.chdir(cwd)

setup((err, project, projPath, outPath)=>{
	if (err) return console.error(err)

	const deps=new Set(project[DEPS])
	if (opt.underscore) deps.add('lib/underscore-min.js')
	if (opt.backbone){
		deps.add('lib/backbone-min.js')
		deps.add('lib/backbone.native.min.js')
	}
	if (opt.lean)deps.add('lib/lean/lean.min.js')
	if (opt.pico)deps.add('lib/pico.min.js')

	const handler={get(target,name){
		switch(name){
		case 'onLoad':
		case 'ajax': return null
		default: return ()=>{}
		}
	}}

	// global
	_=require('underscore')
	Backbone=require('backbone')
	pico=require('./lib/pico.js')
	__=window=document=new Proxy({},handler)

	const filteredProj=[project[DEPS], [...project[STYLE],`${opt.url}${proj}.css`], [], [], {}, project[FLYER]]

	scan(project[MIDDLEWARES], filteredProj[MIDDLEWARES], new Set, new Set, (err, include, style)=>{
		if (err) return console.error(err)
		scan(project[SPEC], filteredProj[SPEC], include, style, (err, include, style)=>{
			if (err) return console.error(err)
			const
			panes=project[PANE],
			keys=Object.keys(panes)

			scanPane(keys, panes, filteredProj[PANE], include, style, (err, include, style)=>{
				if (err) return console.error(err)

				fs.writeFile(projPath, JSON.stringify(filteredProj),(err)=>{
					if (err) return console.error(err)
					writeCSS(style,(err)=>{
						if (err) return console.error(err)

						pico.build({
							entry:path.resolve(modDir,mainjs),
							output:outPath,
							deps:[...deps],
							include:[...include],
							exclude:[path.basename(mainjs,'.js')] 
						})
					})
				})
			})
		})
	})
})
